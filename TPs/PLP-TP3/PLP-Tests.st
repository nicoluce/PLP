Object subclass: #GoalCard	instanceVariableNames: 'set'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!GoalCard commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	set:		<Object>    Implementation Points!!GoalCard methodsFor: 'accessing' stamp: 'Julian 6/20/2017 16:29'!content	"Devuelve el contenido de una GoalCard"	^self set.! !!GoalCard methodsFor: 'accessing' stamp: 'Julian 6/20/2017 16:48'!set	"Devuelve la variable set"	^set.! !!GoalCard methodsFor: 'testing' stamp: 'Julian 6/20/2017 16:41'!isMetBy: aSet	"Pregunta si set esta incluido en aSet haciendo diferencia de conjuntos"	^(self set difference: aSet) isEmpty.! !!GoalCard methodsFor: 'comparing' stamp: 'Julian 6/20/2017 16:29'!= aGoalCard	"Chequea que la clase sea correcta y que el conjunto de objetivos sea igual"		^(aGoalCard isMemberOf: GoalCard) and: [self set = aGoalCard set].	! !!GoalCard methodsFor: 'comparing' stamp: 'Julian 6/20/2017 16:47'!hash	"El mensaje #hash de GoalCard es equivalente a #hash de la variable set."	^self set hash.! !!GoalCard methodsFor: 'initialization' stamp: 'Julian 6/20/2017 16:39'!includes: aTreasureCard	"Consulta si una Goal Card incluye a una Treasure card particular"	^set includes: aTreasureCard.! !!GoalCard methodsFor: 'initialization' stamp: 'Julian 6/20/2017 16:47'!setSet: aSet	"Chequea que los elementos de la Goalcard sean TreasureCard, si es as√≠ los agrega al conjunto"	aSet do: [:element | (element isMemberOf: TreasureCard) ifFalse: [^self error: 'element in set not TreasureCard!!']].	set := aSet.! !!GoalCard methodsFor: 'printing' stamp: 'Julian 6/20/2017 16:46'!printString	"Por cada elemento de la GoalCard, lo imprime en su formato correcto"	| goalString |		goalString := ''.	self set do: [:element | goalString := (goalString, ' '), element printString].	^goalString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GoalCard class	instanceVariableNames: ''!!GoalCard class methodsFor: 'instance creation' stamp: 'NicolasLuce 6/14/2017 11:51'!new: aSet	"comment stating purpose of message"	^self new setSet: aSet.! !Object subclass: #MiniFluxxGame	instanceVariableNames: 'players deck currentPlayerIndex goal winner'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxGame commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	currentPlayerIndex:		<Object>	deck:		<Object>	goal:		<Object>	players:		<Object>	winner:		<Object>    Implementation Points!!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/20/2017 16:45'!play1Turn	| aCard |		deck ifNotEmpty: [self currentPlayer pickFrom: deck]. "Si el mazo no esta vacio el jugadorActual toma una carta."	(self currentPlayer hasCards) ifTrue: [ "Si el jugador tiene cartas en su mano, juega una carta."			aCard := self currentPlayer playCard: self.			(aCard isMemberOf: GoalCard) ifTrue: [goal := aCard]. "Si la carta es una GoalCard remplazo la variable goal por esta."			self checkWinner. "Si el jugador jugo una carta busco si hay un ganador."		].	self pass. "Pasa el turno."! !!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/15/2017 19:45'!deckSize	^deck size.! !!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/15/2017 19:30'!currentPlayer	^players at: currentPlayerIndex.! !!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/20/2017 16:47'!playGame	"Mientras que no haya un ganador y hayan cartas para jugar, el juego continua."	[ winner isNil and: 		[deck isNotEmpty or: 			(players allSatisfy: [:p | p hasCards not]) not		]	] whileTrue: [ self play1Turn ].! !!MiniFluxxGame methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/20/2017 16:36'!checkWinner	"A cada jugador se le envia el mensaje #isWinner, si retorna True entonces la variable de instancia winner sera igual a ese jugador.	Cabe aclarar que de haber dos ganadores, winner sera el ultimo de la coleccion."	players do: [:aPlayer | (self isWinner: aPlayer) ifTrue: [self setWinner: aPlayer]].	! !!MiniFluxxGame methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 19:46'!setPlayers	players := OrderedCollection new.! !!MiniFluxxGame methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 19:26'!setDeck: aDeck	deck := aDeck.! !!MiniFluxxGame methodsFor: 'initialization' stamp: 'NicolasLuce 6/20/2017 16:48'!setStrategy: aStrategy forPlayer: aPlayerName	"Se inicializa la variable strategy al primer jugador con nombre igual al pasado por parametro."	| index |		index := players indexOf: (MiniFluxxPlayer new: aPlayerName) ifAbsent: [self error: 'Player not in game!!'].	(players at: index) strategy: aStrategy.! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 19:32'!players	^players.! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 19:56'!winner	^winner.	! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 19:31'!goal	^goal.! !!MiniFluxxGame methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 19:57'!setWinner: aPlayer	winner := aPlayer.	! !!MiniFluxxGame methodsFor: 'testing' stamp: 'NicolasLuce 6/20/2017 16:40'!isWinner: aPlayer	"Un jugador gana si sus cartas en mesa estan incluidas en la GoalCard actual."	^goal isNotNil and: [goal isMetBy: (aPlayer table)].! !!MiniFluxxGame methodsFor: 'adding' stamp: 'NicolasLuce 6/20/2017 16:32'!addPlayer: aPlayer	players addLast: aPlayer.! !!MiniFluxxGame methodsFor: 'handling' stamp: 'NicolasLuce 6/20/2017 16:41'!pass	"Si el juego no empezo entonces la variable currentPlayerIndex es igual 1, si no sera % (cantidad de jugadores) + 1."	currentPlayerIndex isNil 		ifTrue: [currentPlayerIndex := 1] 		ifFalse: [currentPlayerIndex := (currentPlayerIndex \\ (players size)) + 1].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MiniFluxxGame class	instanceVariableNames: ''!!MiniFluxxGame class methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/15/2017 20:30'!withDeck: aDeck playerNames: players cardsPerPlayer: aNumber	| i aGame cardsPerPlayer|		aGame := self new.	aGame setPlayers.		i := 1.	cardsPerPlayer := aNumber.	aDeck size < (aNumber * (players size)) ifTrue: [cardsPerPlayer := 0].		[i <= (players size)] whileTrue: [ | aPlayer |					aPlayer := MiniFluxxPlayer new: (players at: i). 					aPlayer receive: cardsPerPlayer cardsFrom: aDeck.										aGame addPlayer: aPlayer.										i := i + 1.				].	aGame setDeck: aDeck.	aGame pass.	^aGame.! !Object subclass: #MiniFluxxPlayer	instanceVariableNames: 'name handSize table hand strategy'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxPlayer commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	hand:		<Object>	handSize:		<Object>	name:		<Object>	table:		<Object>    Implementation Points!Object subclass: #MiniFluxxPlayer	instanceVariableNames: 'name handSize table hand strategy'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxPlayer commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	hand:		<Object>	handSize:		<Object>	name:		<Object>	table:		<Object>    Implementation Points!!MiniFluxxPlayer methodsFor: 'initialization' stamp: 'Julian 6/20/2017 16:56'!setName: aName	"Dado un nombre es seteado en la variable name"	name := aName.! !!MiniFluxxPlayer methodsFor: 'initialization' stamp: 'Julian 6/20/2017 16:56'!setHand	"Crea una mano y es seteada en la variable hand"	hand := OrderedCollection new.! !!MiniFluxxPlayer methodsFor: 'initialization' stamp: 'Julian 6/20/2017 16:56'!setTable	"Se crea un conjunto, seteado como la variable table"	table := OrderedCollection new.! !!MiniFluxxPlayer methodsFor: 'as yet unclassified' stamp: 'Julian 6/20/2017 16:55'!receive: aNumber cardsFrom: aDeck	"Toma la cantidad de cartas pasadas por aNumbre de aDeck, llamando a la funci√≥n pickFrom"	| n |		n := aNumber.	[n > 0] whileTrue: [self pickFrom:aDeck. n := n - 1].! !!MiniFluxxPlayer methodsFor: 'as yet unclassified' stamp: 'Julian 6/20/2017 16:49'!meets: aGoalCard	"Chequea si el contenido de table est√° incluida en la GoalCard actual"	^aGoalCard isMetBy: table.! !!MiniFluxxPlayer methodsFor: 'as yet unclassified' stamp: 'Julian 6/20/2017 16:55'!playCard: aGame	"Si no contiene ninguna estrategia, se juega la primer carta de hand.	 De tener estrategia, se llama a esta y se devuelve la carta, eliminandola de la mano    del jugador. En caso de ser TreasureCard es agregada a la mesa del jugador"	| aCard |			strategy ifNil: [			aCard := hand removeFirst.		] 		ifNotNil: [ 				aCard := strategy value: hand value: table value: aGame.				hand remove: aCard.		].	(aCard isMemberOf: TreasureCard) ifTrue: [table addFirst: aCard].	^aCard.! !!MiniFluxxPlayer methodsFor: 'as yet unclassified' stamp: 'Julian 6/20/2017 16:55'!pickFrom: aDeck	"Si el mazo tiene cartas, se eliminar√° la primer carta y ser√° agregada a la variable hand como √∫ltima"	| aCard |		(aDeck isEmpty) ifTrue:[self error: 'Deck is empty!!'].	aCard := aDeck removeFirst.	hand addLast: aCard.	! !!MiniFluxxPlayer methodsFor: 'comparing' stamp: 'Julian 6/20/2017 16:48'!= aPlayer	"Dos jugadores son iguales si tienen el mismo nombre"	^self name = (aPlayer name).! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'Julian 6/20/2017 16:49'!hasCards	"Devuelve si la variable hand no est√° vac√≠a"	^hand isNotEmpty.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'Julian 6/20/2017 16:57'!table	"Retorna la variable table"	^table.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'Julian 6/20/2017 16:48'!handSize	"Devuelve el tama√±o de la variable hand"	^hand size.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'Julian 6/20/2017 16:50'!name	"Devuelve la variable name"	^name.! !!MiniFluxxPlayer methodsFor: 'instance creation' stamp: 'Julian 6/20/2017 16:56'!strategy: aStrategy	"Dado una estrategia, es seteado como la variable strategy"	strategy := aStrategy.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MiniFluxxPlayer class	instanceVariableNames: ''!!MiniFluxxPlayer class methodsFor: 'instance creation' stamp: 'NicolasLuce 6/15/2017 18:29'!new: aName	| player |		player := self new.	player setName: aName.	player setHand.	player setTable.	^player.! !TestCase subclass: #Test01Cards	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test01Cards methodsFor: 'testing' stamp: 'NicolasLuce 6/14/2017 12:29'!test01_3MeetingGoals	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: (s1 isMetBy: (Set with: t1 with: t3)).	self assert: (s1 isMetBy: (Set with: t1 with: t2 with: t3)).   self assert: (s1 isMetBy: (Set with: t1 with: t2)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 11:34'!test01_2GoalCardsEquality	|t1 t2 t3 s1 s2 s3 s4|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := Set with: t1 with: t2.	s2 := Set with: t2 with: t3.	s3 := Set with: t3 with: t2.	s4 := Set with: t3 with: t1.	self assert: (GoalCard new: s1) equals: (GoalCard new: s1).	self assert: (GoalCard new: s2) equals: (GoalCard new: s3).	self assert: (GoalCard new: s2) ~= (GoalCard new: s4).	self assert: (TreasureCard new: s1) ~= s1.	self assert: ((Set with: (GoalCard new: s1)) includes: (GoalCard new: s1)).	self assert: ((Set with: (GoalCard new: s2)) includes: (GoalCard new: s1)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 11:34'!test01_1TreasureCardsEquality	self assert: (TreasureCard new: #tea) equals: (TreasureCard new: #tea).	self assert: (TreasureCard new: #tea) ~= (TreasureCard new: #cookies).	self assert: (TreasureCard new: #tea) ~= #tea.	self assert: ((Set with: (TreasureCard new: #tea)) includes: (TreasureCard new: #tea)).	self assert: ((Set with: (TreasureCard new: #cookies)) includes: (TreasureCard new: #tea)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'NicolasLuce 6/14/2017 13:11'!test01_4CardsAreReadable	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: ('*tea*' match: t1 printString).	self assert: ('*cookies*' match: t2 printString).   self assert: ('*tea*' match: s1 printString).	self assert: ('*milk*' match: s1 printString).! !TestCase subclass: #Test02Players	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_2HandAndDeck	| ana goal deck |	ana := MiniFluxxPlayer new: #Ana.	goal := GoalCard new: (Set with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies)).	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	self assert: (goal isMetBy: deck).	ana pickFrom: deck.	self assert: (goal isMetBy: deck) not.	self assert: ana handSize equals: 1.	ana pickFrom: deck.	self assert: ana handSize equals: 2.	self assert: ana hasCards.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_3ReceiveFromDeck	| ana deck |	ana := MiniFluxxPlayer new: #Ana.	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	ana receive: 2 cardsFrom: deck.	self assert: ana handSize equals: 2.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'NicolasLuce 6/15/2017 18:22'!test02_1PlayerCreation	| ana |	ana := MiniFluxxPlayer new: #Ana.	self assert: ana name equals: #Ana.	self assert: ana handSize equals: 0.	self assert: ana hasCards not.	self assert: ana table isEmpty.! !TestCase subclass: #Test03Games	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 16:56'!test03_8PlayWholeGameWithReverseDeck	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck reverse playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #cookies)).	self assert: game winner name equals: #Ana.	self assert: game winner handSize equals: 1.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game winner meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 6/8/2017 15:00'!test03_5SinglePlayerGame	| game goal |	game := MiniFluxxGame withDeck: self testDeck playerNames: #(Uno) cardsPerPlayer: 3.	goal := GoalCard new: (Set with: (TreasureCard new: #rocket) with: (TreasureCard new: #moon)).	[game winner] whileNil: [game play1Turn].	self assert: game deckSize equals: 7.	self assert: game winner table size equals: 6.	self assert: game winner handSize equals: 3.	self assert: game goal equals: goal.	self assert: game winner name equals: #Uno.	self assert: game currentPlayer equals: game winner.	self assert: (game currentPlayer meets: goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 14:32'!test03_3Pass	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game pass.	self assert: game currentPlayer name equals: #Pedro.	game pass.	self assert: game currentPlayer name equals: #Marina.	game pass.	self assert: game currentPlayer name equals: #Juan.	game pass.	self assert: game currentPlayer name equals: #Ana.! !!Test03Games methodsFor: 'testing' stamp: 'NicolasLuce 6/20/2017 15:09'!test03_6Strategies	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game currentPlayer strategy: st1.	game setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	4 timesRepeat: [game play1Turn].	self assert: game deckSize equals: 8.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Ana.	self assert: game currentPlayer table isEmpty.	self assert: (game players allSatisfy: [:p | p name = #Ana | p table isNotEmpty ]).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_1Initialization	| players game | 	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	self assert: game goal isNil.	self assert: game winner isNil.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 2.	self assert: game deckSize equals: 12.! !!Test03Games methodsFor: 'testing' stamp: 'NicolasLuce 6/15/2017 20:23'!test03_4Play1Turn	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game play1Turn.	self assert: game deckSize equals: 11.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Pedro.! !!Test03Games methodsFor: 'testing' stamp: 'NicolasLuce 6/20/2017 16:12'!test03_9GameEndsInADraw	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: (self testDeck remove: (TreasureCard new: #milk) ; yourself) playerNames: players cardsPerPlayer: 2.	self assert: game deckSize equals: 11.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #love)).	self assert: game winner isNil.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p hasCards not ]).	self assert: (game players allSatisfy: [:p | (p meets: game goal) not ]).! !!Test03Games methodsFor: 'testing' stamp: 'NicolasLuce 6/20/2017 16:07'!test03_7PlayWholeGame	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #milk)).	self assert: game winner name equals: #Juan.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p handSize = 2 ]).	self assert: ((game players detect: [:p | p name = #Juan]) meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_2TooManyCards	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 10.	self assert: game currentPlayer name equals: #Ana.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 0.	self assert: game deckSize equals: 20.! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:08'!testStrategy1	^self class testStrategy1! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^self class testStrategy2.! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck ^self class testDeck! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Test03Games class	instanceVariableNames: ''!!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy1^ [ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ t includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^[ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ (t union: h) includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck|   t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10  g0 g1 g2 g3 g4 g5 g6 g7 g8|t0 := TreasureCard new: #chocolate.t1 := TreasureCard new: #rocket.t2 := TreasureCard new: #moon.t3 := TreasureCard new: #cookies.t4 := TreasureCard new: #money.t5 := TreasureCard new: #love.t6 := TreasureCard new: #peace.t7 := TreasureCard new: #milk.t8 := TreasureCard new: #tea.t9 := TreasureCard new: #time.t10 := TreasureCard new: #hammer.g0 := GoalCard new: (Set with: t0 with: t3).g1 := GoalCard new: (Set with: t1 with: t2).g2 := GoalCard new: (Set with: t5 with: t6).g3 := GoalCard new: (Set with: t7 with: t8).g4 := GoalCard new: (Set with: t9 with: t4).g5 := GoalCard new: (Set with: t3 with: t8).g6 := GoalCard new: (Set with: t0 with: t7).g7 := GoalCard new: (Set with: t9 with: t10).g8 := GoalCard new: (Set with: t3 with: t7).^OrderedCollection new add: g4; add: t5; add: t0; add: g3; add: t6; add: t1; add: g8; add: t7; add: t2; add: g1; add: t8; add: t3; add: g0; add: t9; add: t4 ; add: g5; add: t10; add: g6; add: g7; add: g2 ; yourself.! !Object subclass: #TreasureCard	instanceVariableNames: 'treasure'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!TreasureCard commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	treasure:		<Object>    Implementation Points!!TreasureCard methodsFor: 'printing' stamp: 'NicolasLuce 6/20/2017 16:31'!printString	"Mensaje de impresion en pantalla. Se asume que treasure es la clase String con un formato de '#nombreDelTesoro'"	| treasureString |			treasureString := (self treasure printString substrings: '#') at: 1.	^'*', treasureString, '*'.! !!TreasureCard methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 10:21'!treasure	^treasure.! !!TreasureCard methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 10:21'!setTreasure: aTreasure	treasure := aTreasure.! !!TreasureCard methodsFor: 'comparing' stamp: 'NicolasLuce 6/20/2017 16:28'!= aTreasureCard	"Igualdad de clases. Dos TreasureCard son iguales cuando el nombre de su contenido es el mismo."	^(aTreasureCard isMemberOf: TreasureCard) and: [self treasure == aTreasureCard treasure].! !!TreasureCard methodsFor: 'comparing' stamp: 'NicolasLuce 6/20/2017 16:30'!hash	"El mensaje #hash de TreasureCard es equivalente a #hash de la variable treasure."	^self treasure hash.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TreasureCard class	instanceVariableNames: ''!!TreasureCard class methodsFor: 'instance creation' stamp: 'NicolasLuce 6/14/2017 12:19'!new: aTreasure	"comment stating purpose of message"	^ (TreasureCard new) setTreasure: aTreasure.! !