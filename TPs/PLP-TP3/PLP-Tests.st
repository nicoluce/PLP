Object subclass: #GoalCard	instanceVariableNames: 'set'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!GoalCard commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	set:		<Object>    Implementation Points!!GoalCard methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 10:23'!setSet: aSet	aSet do: [:element | (element isMemberOf: TreasureCard) ifFalse: [^self error: 'element in set not TreasureCard!!']].	set := aSet.! !!GoalCard methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 10:23'!set	^set.! !!GoalCard methodsFor: 'comparing' stamp: 'NicolasLuce 6/15/2017 10:22'!= aGoalCard		^(aGoalCard isMemberOf: GoalCard) and: [self set = aGoalCard set].	! !!GoalCard methodsFor: 'comparing' stamp: 'NicolasLuce 6/15/2017 10:23'!hash	^self set hash.! !!GoalCard methodsFor: 'testing' stamp: 'NicolasLuce 6/15/2017 10:23'!isMetBy: aSet	^(self set difference: aSet) isEmpty.! !!GoalCard methodsFor: 'printing' stamp: 'NicolasLuce 6/15/2017 10:23'!printString	| goalString |		goalString := ''.	self set do: [:element | goalString := (goalString, ' '), element printString].	^goalString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GoalCard class	instanceVariableNames: ''!!GoalCard class methodsFor: 'instance creation' stamp: 'NicolasLuce 6/14/2017 11:51'!new: aSet	"comment stating purpose of message"	^self new setSet: aSet.! !Object subclass: #MiniFluxxPlayer	instanceVariableNames: 'name handSize table hand'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!MiniFluxxPlayer commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	hand:		<Object>	handSize:		<Object>	name:		<Object>	table:		<Object>    Implementation Points!!MiniFluxxPlayer methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/15/2017 18:49'!pickFrom: aDeck	| aCard |		(aDeck isEmpty) ifTrue:[self error: 'Deck is empty!!'].	aCard := aDeck removeFirst.	hand addLast: aCard.	! !!MiniFluxxPlayer methodsFor: 'as yet unclassified' stamp: 'NicolasLuce 6/15/2017 18:59'!receive: aNumber cardsFrom: aDeck	| n |		n := aNumber.	[n > 0] whileTrue: [self pickFrom:aDeck. n := n - 1].! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 18:32'!handSize	^hand size.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 18:33'!hasCards	^hand isNotEmpty.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 18:32'!name	^name.! !!MiniFluxxPlayer methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 18:25'!table	^table.! !!MiniFluxxPlayer methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 18:19'!setName: aName	name := aName.! !!MiniFluxxPlayer methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 18:30'!setHand	hand := OrderedCollection new.! !!MiniFluxxPlayer methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 18:30'!setTable	table := OrderedCollection new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MiniFluxxPlayer class	instanceVariableNames: ''!!MiniFluxxPlayer class methodsFor: 'instance creation' stamp: 'NicolasLuce 6/15/2017 18:29'!new: aName	| player |		player := self new.	player setName: aName.	player setHand.	player setTable.	^player.! !TestCase subclass: #Test01Cards	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test01Cards methodsFor: 'testing' stamp: 'NicolasLuce 6/14/2017 12:29'!test01_3MeetingGoals	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: (s1 isMetBy: (Set with: t1 with: t3)).	self assert: (s1 isMetBy: (Set with: t1 with: t2 with: t3)).   self assert: (s1 isMetBy: (Set with: t1 with: t2)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 11:34'!test01_2GoalCardsEquality	|t1 t2 t3 s1 s2 s3 s4|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := Set with: t1 with: t2.	s2 := Set with: t2 with: t3.	s3 := Set with: t3 with: t2.	s4 := Set with: t3 with: t1.	self assert: (GoalCard new: s1) equals: (GoalCard new: s1).	self assert: (GoalCard new: s2) equals: (GoalCard new: s3).	self assert: (GoalCard new: s2) ~= (GoalCard new: s4).	self assert: (TreasureCard new: s1) ~= s1.	self assert: ((Set with: (GoalCard new: s1)) includes: (GoalCard new: s1)).	self assert: ((Set with: (GoalCard new: s2)) includes: (GoalCard new: s1)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 11:34'!test01_1TreasureCardsEquality	self assert: (TreasureCard new: #tea) equals: (TreasureCard new: #tea).	self assert: (TreasureCard new: #tea) ~= (TreasureCard new: #cookies).	self assert: (TreasureCard new: #tea) ~= #tea.	self assert: ((Set with: (TreasureCard new: #tea)) includes: (TreasureCard new: #tea)).	self assert: ((Set with: (TreasureCard new: #cookies)) includes: (TreasureCard new: #tea)) not.! !!Test01Cards methodsFor: 'testing' stamp: 'NicolasLuce 6/14/2017 13:11'!test01_4CardsAreReadable	|t1 t2 t3 s1|	t1 := TreasureCard new: #tea.	t2 := TreasureCard new: #cookies.	t3 := TreasureCard new: #milk.	s1 := GoalCard new: (Set with: t1 with: t3).   self assert: ('*tea*' match: t1 printString).	self assert: ('*cookies*' match: t2 printString).   self assert: ('*tea*' match: s1 printString).	self assert: ('*milk*' match: s1 printString).! !TestCase subclass: #Test02Players	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_2HandAndDeck	| ana goal deck |	ana := MiniFluxxPlayer new: #Ana.	goal := GoalCard new: (Set with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies)).	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	self assert: (goal isMetBy: deck).	ana pickFrom: deck.	self assert: (goal isMetBy: deck) not.	self assert: ana handSize equals: 1.	ana pickFrom: deck.	self assert: ana handSize equals: 2.	self assert: ana hasCards.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 13:40'!test02_3ReceiveFromDeck	| ana deck |	ana := MiniFluxxPlayer new: #Ana.	deck := OrderedCollection with: (TreasureCard new: #chocolate) with: (TreasureCard new: #cookies) with: (TreasureCard new: #tea).	ana receive: 2 cardsFrom: deck.	self assert: ana handSize equals: 2.	self assert: deck first equals: (TreasureCard new: #tea).! !!Test02Players methodsFor: 'testing' stamp: 'NicolasLuce 6/15/2017 18:22'!test02_1PlayerCreation	| ana |	ana := MiniFluxxPlayer new: #Ana.	self assert: ana name equals: #Ana.	self assert: ana handSize equals: 0.	self assert: ana hasCards not.	self assert: ana table isEmpty.! !TestCase subclass: #Test03Games	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 16:56'!test03_8PlayWholeGameWithReverseDeck	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck reverse playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #cookies)).	self assert: game winner name equals: #Ana.	self assert: game winner handSize equals: 1.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game winner meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 6/8/2017 14:53'!test03_6Strategies	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game currentPlayer strategy: st1.	game setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	4 timesRepeat: [game play1Turn].	self assert: game deckSize equals: 8.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Ana.	self assert: game currentPlayer table isEmpty.	self assert: (game players allSatisfy: [:p | p name = #Ana | p table isNotEmpty ]).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 14:32'!test03_3Pass	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game pass.	self assert: game currentPlayer name equals: #Pedro.	game pass.	self assert: game currentPlayer name equals: #Marina.	game pass.	self assert: game currentPlayer name equals: #Juan.	game pass.	self assert: game currentPlayer name equals: #Ana.! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 6/8/2017 15:00'!test03_5SinglePlayerGame	| game goal |	game := MiniFluxxGame withDeck: self testDeck playerNames: #(Uno) cardsPerPlayer: 3.	goal := GoalCard new: (Set with: (TreasureCard new: #rocket) with: (TreasureCard new: #moon)).	[game winner] whileNil: [game play1Turn].	self assert: game deckSize equals: 7.	self assert: game winner table size equals: 6.	self assert: game winner handSize equals: 3.	self assert: game goal equals: goal.	self assert: game winner name equals: #Uno.	self assert: game currentPlayer equals: game winner.	self assert: (game currentPlayer meets: goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_1Initialization	| players game | 	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	self assert: game goal isNil.	self assert: game winner isNil.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 2.	self assert: game deckSize equals: 12.! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/27/2017 10:02'!test03_9GameEndsInADraw	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: (self testDeck remove: (TreasureCard new: #milk) ; yourself) 							                         playerNames: players cardsPerPlayer: 2.	self assert: game deckSize equals: 11.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #love)).	self assert: game winner isNil.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p hasCards not ]).	self assert: (game players allSatisfy: [:p | (p meets: game goal) not ]).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:40'!test03_4Play1Turn	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	self assert: game currentPlayer name equals: #Ana.	game play1Turn.	self assert: game deckSize equals: 11.	self assert: (game goal includes: (TreasureCard new: #time)).	self assert: game currentPlayer name equals: #Pedro.! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:30'!test03_7PlayWholeGame	| st1 st2 players game |	st1 := self testStrategy1.	st2 := self testStrategy2.  	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 2.	game setStrategy: st1 forPlayer: #Ana ;	setStrategy: st1 forPlayer: #Juan ; setStrategy: st2 forPlayer: #Marina.	game playGame.	self assert: game deckSize equals: 0.	self assert: (game goal includes: (TreasureCard new: #milk)).	self assert: game winner name equals: #Juan.	self assert: (game players allSatisfy: [:p | p table isNotEmpty ]).	self assert: (game players allSatisfy: [:p | p handSize = 2 ]).	self assert: ((game players detect: [:p | p name = #Juan]) meets: game goal).! !!Test03Games methodsFor: 'testing' stamp: 'GabrielaSteren 5/25/2017 15:18'!test03_2TooManyCards	| players game |	players := #(Ana Pedro Marina Juan).	game := MiniFluxxGame withDeck: self testDeck playerNames: players cardsPerPlayer: 10.	self assert: game currentPlayer name equals: #Ana.	self assert: game players size equals: 4.	self assert: game currentPlayer handSize equals: 0.	self assert: game deckSize equals: 20.! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:08'!testStrategy1	^self class testStrategy1! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^self class testStrategy2.! !!Test03Games methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck ^self class testDeck! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Test03Games class	instanceVariableNames: ''!!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy1^ [ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ t includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:09'!testStrategy2	^[ :h :t :game | 		| g | g := game goal. 		h detect: [ :c | (c isKindOf: GoalCard) and: [ (t union: h) includesAll: c content] ] 		  ifNone:[			g ifNil: [ h first ] 			  ifNotNil: [h detect: [:c | g includes: c] ifNone: [h last]]		  ]	 ].! !!Test03Games class methodsFor: 'for testing' stamp: 'GabrielaSteren 5/25/2017 15:07'!testDeck|   t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10  g0 g1 g2 g3 g4 g5 g6 g7 g8|t0 := TreasureCard new: #chocolate.t1 := TreasureCard new: #rocket.t2 := TreasureCard new: #moon.t3 := TreasureCard new: #cookies.t4 := TreasureCard new: #money.t5 := TreasureCard new: #love.t6 := TreasureCard new: #peace.t7 := TreasureCard new: #milk.t8 := TreasureCard new: #tea.t9 := TreasureCard new: #time.t10 := TreasureCard new: #hammer.g0 := GoalCard new: (Set with: t0 with: t3).g1 := GoalCard new: (Set with: t1 with: t2).g2 := GoalCard new: (Set with: t5 with: t6).g3 := GoalCard new: (Set with: t7 with: t8).g4 := GoalCard new: (Set with: t9 with: t4).g5 := GoalCard new: (Set with: t3 with: t8).g6 := GoalCard new: (Set with: t0 with: t7).g7 := GoalCard new: (Set with: t9 with: t10).g8 := GoalCard new: (Set with: t3 with: t7).^OrderedCollection new add: g4; add: t5; add: t0; add: g3; add: t6; add: t1; add: g8; add: t7; add: t2; add: g1; add: t8; add: t3; add: g0; add: t9; add: t4 ; add: g5; add: t10; add: g6; add: g7; add: g2 ; yourself.! !Object subclass: #TreasureCard	instanceVariableNames: 'treasure'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP-Tests'!!TreasureCard commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	treasure:		<Object>    Implementation Points!!TreasureCard methodsFor: 'printing' stamp: 'NicolasLuce 6/15/2017 10:21'!printString	| treasureString |			treasureString := (self treasure printString substrings: '#') at: 1.	^'*', treasureString, '*'.! !!TreasureCard methodsFor: 'accessing' stamp: 'NicolasLuce 6/15/2017 10:21'!treasure	^treasure.! !!TreasureCard methodsFor: 'initialization' stamp: 'NicolasLuce 6/15/2017 10:21'!setTreasure: aTreasure	treasure := aTreasure.! !!TreasureCard methodsFor: 'comparing' stamp: 'NicolasLuce 6/15/2017 10:22'!= aTreasureCard	^(aTreasureCard isMemberOf: TreasureCard) and: [self treasure == aTreasureCard treasure].! !!TreasureCard methodsFor: 'comparing' stamp: 'NicolasLuce 6/15/2017 10:19'!hash	^self treasure hash.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TreasureCard class	instanceVariableNames: ''!!TreasureCard class methodsFor: 'instance creation' stamp: 'NicolasLuce 6/14/2017 12:19'!new: aTreasure	"comment stating purpose of message"	^ (TreasureCard new) setTreasure: aTreasure.! !